## 好玩又好懂的圆周率计算方法

3.141592653——普通人对圆周率（π）的小数点后几位数可能就背到这里了，但数学家、科学家们的计算要比这个数字精确得多。

公元前3世纪，古希腊大数学家阿基米德第一个给出了计算圆周率π的科学方法（并算出π在3.140845与3.142857之间）。公元5世纪，中国南北朝时期的大科学家祖冲之用三国时代数学家刘徽发明的割圆术（与阿基米德的方法类似）算出了3.1415926<π<3.1415927，成为此后千年世界上最准确的圆周率。

公元16至17世纪，采用微积分和幂级数展开方法，帕斯卡、牛顿、莱布尼茨对π的计算做出巨大贡献。到1706年，英国数学家梅钦（John Machin）得出了现今以其名字命名的公式，给出了π值的第一个快速算法，并算到了小数点后100位。

然而真正让π的精确位数得到魔术般提升的是20世纪中计算机的发明，很快就让π的计算精度提高到千位、万位、百万位，直至万亿位[1]。2019年3月14日，也是“圆周率日”，Google 宣布将π的计算精确到了小数点后31.4万亿位[2]。

现在，有了好玩又好学的Python，我们也可以试试自己来编程算算圆周率了。虽然做不到Google那么高的精度，但也可以做得相当好哦。

### 1、蒙特卡洛法：非常直观易懂，但效率极低

蒙特卡洛是欧洲著名赌城，计算机里的蒙特卡洛法就是指用随机数的方法。

设想一个正方形，边长为2，则其内接圆的半径是1。它们的面积比是：Sy/Sz = π*r^2 / 4

因此, π = 4*Sy/Sz

我们用蒙特卡洛法来获得面积比Sy/Sz：产生很多的随机点(x,y)，其中x、y都是[0,1]之间的随机数，那么判断x^2+y^2是否小于1来确定是否在圆内，则圆内的点数代表圆面积，总点数代表总面积，两者相除就是面积比Sy/Sz。

上述过程很直观很好理解吧？Python代码如下：

```
import random

num_all = 0         #随机点总计数器
num_cir = 0         #随机点在圆内的计数器
num_halt = 10000000 #每产生这么多个随机点后，计算并打印一次目前的结果

print("将进行无限计算，请用Ctrl_C或其他方式强制退出！！！")
input("按回车(Enter)键开始...")
print("开始计算...，退出请用Ctrl_C或其他强制退出方式...")
print("\n实验次数        计算结果")

while 1 :
    for i in range(num_halt): 
        x = random.random()         #获得随机点的横坐标
        y = random.random()         #获得随机点的纵坐标
        if x*x + y*y < 1 :          #随机点(x,y)在圆内
            num_cir = num_cir + 1   #圆内计数器+1
        num_all = num_all + 1       #总计数器+1
    pi = 4*num_cir/num_all
    print(num_all,"   ", pi)

```

通过运算我们发现，计算结果的收敛是很慢的，算到13亿5千个随机点，才收敛到3.14159，如下所示：

	实验次数         计算结果
	13350000000     3.1415928419475656
	13360000000     3.141593166766467
	13370000000     3.1415929427075544
	13380000000     3.1415930633781763
	13390000000     3.1415925159073934
	13400000000     3.141592089850746
	13410000000     3.1415922147651005
	13420000000     3.141592147839046
	13430000000     3.1415921915115415
	13440000000     3.14159239375
	13450000000     3.1415922649814125

数学上可以证明，蒙特卡洛法每提高一位精度，需要提高100倍的计算量，因此达到上述小数点后面5位的精度如果花了1小时的话，6位要100小时，7位要一年多，8位要100多年。可见，用蒙特卡洛方法要把π算到小数点后面10位以上是很艰难的。即使用效率高得多的C语言，同样时间内也顶多再提高一两位的精度。如果放到大型计算机上去，也提高不了几位。

可见蒙特卡洛法虽然很直观，容易理解，但效率和精度不高，并不实用。不过蒙特卡洛法本身，在计算机程序中还是相当重要的，在其它程序中可能很好用呢。

### 2、割圆迭代法：也很直观易懂，效率还不错

现在我们用刘徽和祖冲之的割圆术试试。

原理是这样的：设想一个圆，半径为1，内接一个正n边形，边长为a，那么当这个多边形边数n越大，它的周长就接近圆的周长。所以我们就用多边形的周长代替圆的周长并应用圆的周长公式得到：π = n*a/2。

圆的内接正n边形边长a可以迭代计算：a[n]=sqrt(2-2*sqrt(1-(a[n/2]/2)**2))。我们从正六边形开始，它的边长a=r=1，然后是正12边形、正24边形...

代码如下：

```
import math
import math
import math
n=6
a=1
print("%-15s%-20s" % ("内接正n边形","π计算结果"))
print("%-20d%-20.12f" % (n, n*a/2))
for i in range(14) :
  n=2*n
  a=math.sqrt(2-2*math.sqrt(1-(a/2)**2))
  print("%-20d%-20.12f" % (n, n*a/2))
```
计算结果如下：

```
内接正n边形           π计算结果               
6                   3.000000000000      
12                  3.105828541230      
24                  3.132628613281      
48                  3.139350203047      
96                  3.141031950891      
192                 3.141452472285      
384                 3.141557607912      
768                 3.141583892149      
1536                3.141590463237      
3072                3.141592106043      
6144                3.141592516588      
12288               3.141592618641      
24576               3.141592645321      
49152               3.141592645321      
98304               3.141592645321  
```
我们可以看到，因为计算机精度原因，算到49512边形就无法继续提高计算结果的精度了（64位机）。所以我们算到了π=3.141592645，也蛮不错的，毕竟到祖冲之的精度了。

也许可以从算法上想一些办法去提高这个精度，但这里就不深入了，因为下面我们的杀手锏就要来了。

### 3、梅钦级数法：虽不直观也易懂，效率很高

### 参考

[1] https://zh.wikipedia.org/wiki/圓周率

[2] https://www.qdaily.com/articles/62096.html
